"""
Integration test: end-to-end validate → split → smoke pipeline.

Marked as integration because it may require data loading infrastructure.
"""

import subprocess
import sys
from pathlib import Path

import pytest

pytestmark = pytest.mark.integration


class TestPipelineEndToEnd:
    """Integration tests for the data governance pipeline."""

    def test_validate_data_cli_help(self):
        """validate-data CLI should respond to --help."""
        from atlas.data.data_validation import build_parser
        parser = build_parser()
        # Just verify parser builds without error
        assert parser.prog == "validate-data"

    def test_make_splits_cli_help(self):
        """make-splits CLI should respond to --help."""
        from atlas.data.split_governance import build_parser
        parser = build_parser()
        assert parser.prog == "make-splits"

    def test_validate_synthetic_data(self):
        """Validation pipeline on synthetic records should pass cleanly."""
        from atlas.data.data_validation import validate_dataset

        records = [
            {
                "jid": f"TEST-{i}",
                "atoms": {"coords": [[0, 0, 0]]},
                "provenance_type": "dft_primary",
                "source_key": "test",
                "source_version": "1.0",
                "source_id": f"TEST-{i}",
                "formation_energy": float(i) * 0.1,
            }
            for i in range(50)
        ]

        split_ids = {
            "train": {f"TEST-{i}" for i in range(30)},
            "val": {f"TEST-{i}" for i in range(30, 40)},
            "test": {f"TEST-{i}" for i in range(40, 50)},
        }

        report = validate_dataset(
            records,
            split_ids=split_ids,
            properties=["formation_energy"],
        )

        assert report.gate_pass is True
        assert report.schema_violations == 0
        assert report.provenance_missing == 0
        assert report.leakage_count == 0

    def test_split_then_validate_no_leakage(self):
        """Splits generated by split_governance should pass leakage check."""
        from atlas.data.data_validation import check_leakage
        from atlas.data.split_governance import iid_split

        ids = [f"S{i}" for i in range(200)]
        splits = iid_split(ids, seed=42)

        split_ids = {k: set(v) for k, v in splits.items()}
        overlap = check_leakage(split_ids)
        assert all(v == 0 for v in overlap.values())

    def test_compositional_split_then_validate(self):
        """Compositional splits should have zero leakage."""
        from atlas.data.data_validation import check_leakage
        from atlas.data.split_governance import compositional_split

        ids = [f"S{i}" for i in range(100)]
        formulas = [f"El{i % 15}O" for i in range(100)]
        splits = compositional_split(ids, formulas, seed=42)

        split_ids = {k: set(v) for k, v in splits.items()}
        overlap = check_leakage(split_ids)
        assert all(v == 0 for v in overlap.values())

    def test_full_pipeline_synthetic(self):
        """End-to-end: create data → validate → split → verify."""
        from atlas.data.data_validation import validate_dataset
        from atlas.data.split_governance import (
            generate_manifest,
            iid_split,
        )

        # 1. Create synthetic data
        records = [
            {
                "jid": f"PIPE-{i}",
                "atoms": {"element": "Fe"},
                "provenance_type": "synthetic",
                "source_key": "test_gen",
                "source_version": "0.1",
                "source_id": f"PIPE-{i}",
                "formation_energy": float(i) * 0.05 - 1.0,
            }
            for i in range(100)
        ]

        # 2. Validate
        ids = [r["jid"] for r in records]
        splits = iid_split(ids, seed=42)
        split_ids = {k: set(v) for k, v in splits.items()}

        report = validate_dataset(
            records,
            split_ids=split_ids,
            properties=["formation_energy"],
        )
        assert report.gate_pass is True

        # 3. Generate manifest
        manifest = generate_manifest("iid", splits, seed=42)
        assert manifest.split_hash.startswith("sha256:")
        assert manifest.splits["train"]["n_samples"] > 0

        # 4. Verify manifest hash is stable
        manifest2 = generate_manifest("iid", splits, seed=42)
        assert manifest.split_hash == manifest2.split_hash

    def test_phase1_preflight_only_dry_run(self):
        """Phase1 launcher should support mandatory preflight in dry-run mode."""
        project_root = Path(__file__).resolve().parents[2]
        script = project_root / "scripts/phase1_baseline/run_phase1.py"
        cmd = [
            sys.executable,
            str(script),
            "--preflight-only",
            "--dry-run",
        ]
        completed = subprocess.run(cmd, cwd=str(project_root), check=False)
        assert completed.returncode == 0
